learn the basics- type casting,exception,function , builtin function , list , tuples , sets , dictionaries

type casting-
3 types-
  int(),float(),str()
  x=int(3)
y=float(3.4)
z=str(56)

exception-arithmetic error, assertion error, exception,indentation error, loookuperror
memoryerror
a=[1,2,4]
try:
  print()
  except:
  print()

raise statement- allows the programmer to force a specific exception to occur.

try:
  raise Nameerror("hi there")
except Nameerror:
print("an exception")

list is a collection which is ordered and changeable.Allows a duplicate member
a=[1,5,6,7,"gbg","rgb]
   tuple- is a collection which is ordered and unchangeable .allows duplicate members.

   x={3,4,5,6}

   set- is unordered and unchangebale and no duplicate memebers

   myset={"apple","banaban","cherry"}

   dictionaries- ordered and changeable and no duplicate memebers.
   thisdict={
   "brand":"ford"
   "year":56
   "name":"sarth"

data structures and algorithgm
1)arrays and linked list
a=arr.array('d',[1,2,1,3])
a.append(3.4),a.extend,pop,concadenate
collection of ordered series element of same type.a list can store any value while 
array store same value.
2)hash tables
3)heaps, stacks and queues
4)binary search tree
5)recursion
6)sorting algorithm
 am module is a file containing python definition and statment with .py

lambda is a anonymous function 

it can take any argument but only one expression
x=lambda a:a+10
print(x(5))
x=lambda a,b: a+b
print(x(5,6))

decorators add fuctionality to a existing function

def hello(func):
def inner():
print('hello')
func()
return inner
def name():
print("alice")
obj=hello(name)
obj()

list compresion

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
new list=[x for x in fruits if a in x]
print(new list)

genrator return iterator it contains yeild statement return a generator object

def squares(length):
for n in range(lenght):
tield n*2

python supoorts imperative programming paradigm- it executes commands in a step by step manner

functional programming paradigm
computation based on lambda calculus , it approah is what to solve approah

procedural programming paradigm- same as imperative programming

he procedural programming paradigm facilitates the practice of good program design and allows modules to be reused in the form of code libraries.

object oriented programming paradigm
class stringops:
def __init__(self,charaters):
self.characters=characters
def stringify(self):
self.string=''.join(self.characters)

write() can be used to write to a open stream
context managaer define with statment and enter()exit() methods

join(),aquire(),release()

asynchrony- without blocking,using asyn and await , it is used for networking, file manipulation 

   

gil is used to allow one thread to execute at an time.
start()
daemon- is a process that runs in background
start()Â¶
run()
join(timeout=None)
is_alive()
daemon
release()

pytest 
def test_greater():
   num = 100
   assert num > 100

def test_greater_equal():
   num = 100
   assert num >= 100

def test_less():
   num = 100
   assert num < 200

Pytest allows us to use markers on test functions.
import pytest
@pytest.mark.great
def test_greater():
   num = 100
   assert num > 100

@pytest.mark.great
def test_greater_equal():
   num = 100
   assert num >= 100

@pytest.mark.others
def test_less():
   num = 100
   assert num < 200

Parameterizing of a test is done to run the test against multiple sets of inputs. We can do this by using the following marker âˆ’
import pytest

@pytest.mark.parametrize("num, output",[(1,11),(2,22),(3,35),(4,44)])
def test_multiplication_11(num, output):
   assert 11*num == output

This xml file is mainly useful in cases where we have a dashboard that projects the test results.
pytest test_multiplication.py -v --junitxml="result.xml"

Pytest can run multiple tests in parallel, which reduces the execution time of the test suite.

Pytest has its own way to detect the test file and test functions automatically, if not mentioned explicitly.

Pytest allows us to skip a subset of the tests during execution

start()
run()
join()

locking - acquire()-to lock the thread
release()- changes the state to unlock
A reentrant lock is a synchronization primitive that may be acquired multiple times by the same thread.
, wait() re-acquires the lock and returns.
The notify() method wakes up one of the threads waiting for the condition variable, if any are waiting.
class - it a collection of object - it contain attributes of objects.
object- it has behaviour and state

class student:
def __init__(self,name, class):
self.name=name
self.class=class
def car(self):
print(self.name,self.class)
c1=student("sarth",4)
c1.car()

method define what object want to tell with help of method.

single derived inheritance-

class animal:
def bark(self):
print("dog")
class human(animal):
def cat(self):
print("meow")
c1=cat()
c1.bark()
c1.cat()

